# 1. Tcp /ip 흐름제어 (수현)
## 1.1TCP 3 & 4 way Hand Shake
1. TCP 연결할때 어떻게 연결이되는지 SYN과 ACK 관계로 설명해주세요.
    ``` 
    1. 클라이언트가 서버에게 SYN 플래그를 보냄(seq:1이라 가정)
    2. 서버는 클라이언트에게 SYN에대한 응답으로 ACK를 보냄과동시에 그후 연결초기화를 위한 SYN을 같이전송함(ack: 는 seq를 잘받았다는 의미로 2를 보냄, seq는 임의의숫자 10을보냄)
    3. 클라이언트는 SYN에대한 응답으로 ACK보냄
    ``` 
2. FIN WAIT1과 FIN WAIT2의 상태는 언제보이나요?
    ```
    FIN_WAIT1: 클라이언트가 FIN 플래그를 전송할때(ACK응답 못받았을때)
    FIN_WAIT2: 클라이언트가 FIN 플래그 전송에대한 ACK을 받았을때(ACK에대한 FIN 응답을 못받았을때)

    ```
3. passive close와 active close에 대해서 설명해주 세요. 
    ```
    active_close: FIN을 먼저 보내는쪽
    passive_close FIN Flag를 받는쪽
    ```
## 1.2 TCP/IP 흐름제어 혼잡제어
1. TCP 통신의 특징을 말씀해주세요
    ```
    1. 신뢰성이 있는 연결
     - 손실, 순서바뀜, 중복 ACK등이 없도록 보장함
    ```
2. TCP 통신이 가능하게 하는 TCP 대표적 기능이 무엇일까요?
    ```
    흐름제어, 혼잡제어
    ```
3. 흐름제어에 대해 설명해주세요
    ```
    송수신의 속도차이를 해결하기 위한 방법
    송신자가 수신자가 읽어들이는것에비해 너무 빠르면 수신자의 버퍼가 overflow난다. 이를 해결하는 법
    해결법: 
        - datalink층에서 해결법: stop-and -wait, go-back-N
        - datalink가 아닌곳에서 해법: receive window size를 전송해서 해결 가능한 만큼만 보내느 방법
    ```
2. 혼잡제어에 대해 설명해주세요.
    ```
    - packet 충돌등으로 패킷이 손실이나 잘못된 패킷이 왔을때에대해 전송 크기를 조절하여 전송하는것
    - Timeout, 중복 ACk감지시 혼잡자에 알고리즘 사용
    - 혼잡윈도(cwnd) 를 사용함
    - slow start: 2의 지수만큼 증가됨
    - 혼잡회피: cwnd=i인 느린시작임계치에 도달하면 혼잡 윈도 1씩 만증가
    - reno, cubic등이 혼잡제어 알고리즘에 속함
    ```
# 2. Udp 대칭키 공개키
1. UDP 란 무엇인가요?
    ```
    → UDP : 데이터그램 단위로 처리하는 프로토콜, 비연결성, 신뢰성 없는 전송 프로토콜
    ```
    
2. UDP Header 구조는 어떻게 이루어져 있나요?
    ```
    → Source 포트, Destination 포트, 길이, checksum (오류 검출)
    ```
    
3. UDP는 어디에 사용되는 것인가요?
    ```
    → 신속성, 처리가 빠름, 실시간 방송이나 온라인 게임에서 사용
    ```
    
4. DNS (Domain Name Service) 에서 UDP 사용하는 이유는?
    ```
    UDP는  아래와 같은 특징을 가지고 있기에 DNS에 더 적합하며

    DNS는 UDP 를 53번 포트에서 사용한다.

    1)  3 way handshaking으로 연결을 유지할 필요가 없다
    2) Request 양이 작아서 UDP Segment 에 담길 수 있다.
    3) Request에 대한 손실은 Application Layer에서 제어가 가능하다.

    → 도메인 네임을 ip로 변경함으로 항상 많은 클라이언트를 수용하는 DNS 서버에게는 연경 상태를 유지하지 않아 정보 기록을 최소화하는 UDP가 알맞음
    ```
    
 5. DNS에서 TCP 를 사용하는 경우는 언제인가?
    ```
    1)  Zone Transfer 를 사용해야 하는 경우
    cf) Zone Transfer : DNS 서버 간의 요청을 주고 받을 때 사용하는 transfer

    2) 데이터가 512 bytes를 넘거나, 응답을 못받은 경우
    ```
    
 6. DNS에서 TCP 를 사용하는 경우는 언제인가?
    ```
    1)  Zone Transfer 를 사용해야 하는 경우
    cf) Zone Transfer : DNS 서버 간의 요청을 주고 받을 때 사용하는 transfer
    2) 데이터가 512 bytes를 넘거나, 응답을 못받은 경우 
    ``` 
    
  7. 대칭키란 무엇이고 장점과 단점은 무엇인가?
     ```
     암호화와 복호화에 같은 암호키 (대칭키)를 사용하는 알고리즘
     
     장점: 동일한 키를 주고 받기에, 매우 빠름
     단점: 대칭키 전달과정에서 해킹 위험에 노출
     ```
     
  8. 공개키란 무엇이고 장점과 단점은 무엇인가?
     ```
     암호화와 복호화에 사용하는 암호키를 분리한 알고리즘으로
     자신이 가지고 있는 고유한 암호키 (Private Key) 로맘 복호화할 수 있는  암호키  (Public Key) 를 대중에 공개
     
     장점: 해킹 위험에 노출되는 것을 해결
     단점: 암복호화가 매우 복잡
     ```
     
 9. SSL (Secure Socket  Layer) 의 과정에 대해 설명하시오
    ```
    대칭키와 공개키 통합 암호화 방식으로, 
    대칭키를 주고 받을 때만 공개키 암호화 방식을 사용하고, 이후에는 계속 대칭키 암호화 방식으로 통신한다.
     ```
     
    ```
    1. 사이트(특히 전자상거래 기관)은 인증기관에 자신의 정보와 공개키를 제출한다.
    2. 인증기관은 정보를 면밀히 검토한뒤, 사이트의 정보와 공개키를 자신의 비밀키로 암호화한다.
    3. 인증기관은 인증기관의 비밀키로 암호화된 사이트의 정보와 공개키를 사이트에 송신한다.
    4. 개인이 브라우저를 통해 사이트에 접속하면, 암호화된 사이트의 정보와 공개키를 사이트로 부터 받는다.
    5. 브라우저는 인증기관의 공개키(이 공개키는 브라우저에게만 제공된다.)로 이를 복호화하여 사이트의 공개키를 얻는다.
    6. 브라우저가 대칭키를 사이트의 공개키로 암호화하여 사이트에 보낸다.
    7. 사이트는 자신의 개인키로 암호화된 대칭키를 복호화한다.
    8. 이제 개인과 사이트는 대칭키로 통신할 수 있다.
    ```
     
# 3. Blocking non blocking 
1. Blocking과 non blocking에 대해서 설명해주세요. 
    ``` 
    1. Blocking : 함수 B는 내 할 일을 다 마칠 때까지 제어권을 가지고 있는다. A는 B가 다 마칠 때까지 기다려야 한다.
    2. Non-blocking : 함수 B는 할 일을 마치지 않았어도 A에게 제어권을 바로 넘겨준다. A는 B를 기다리면서도 다른 일을 진행할 수 있다.
    ``` 
2. Synchronous/Asynchronous에 대해서 설명해주세요. 
    ```
    Synchronous : 함수 A는 함수 B가 일을 하는 중에 기다리면서, 현재 상태가 어떤지 계속 체크한다.
    Asynchronous : 함수 B의 수행 상태를 B 혼자 직접 신경쓰면서 처리한다. (Callback)

    ```
3. Blocking I/O 와 Non-Blocking I/O의 차이를 설면해주세요. 
    ```
    I/O 작업이 진행되는 동안 user Process(Thread) 는 자신의 작업을 중단한 채 대기.
    Non-Blocking I/O 작업이 진행되는 동안 User Process의 작업을 중단하지 않음.

# 4. Http 로드밸런싱

## http
인터넷 상의 서버와 클라이언트 사이의 통신 규약
여기에 보안이 추가된 https가 있다

## https
인터넷상의 정보를 암호화하는 ssl 프로토콜을 사용해 암호화

## 통신 흐름
1. 어플리케이션 서버를 만드는 기업은 https를 적용하기 위해 공개키와 개인키를 만든다
2. 신뢰 할 수 있는 ca기업을 선택하고, 그 기업에게 내 공개키 관리를 부탁하여 계약을 한다
ca: certificate authority로, 공개키를 저장해주는 신뢰성 있는 기업
3. ca기업은 서버의 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 ca기업의 개인키로 암호화해서 서버에 제공
4. 서버는 암호화된 인증서를 갖게 된다 이제 서버는 서버의 공개키로 암호하된 https 요청이 아닌 요청이 오면, 암호화된 인증서를 클라이언트에 준다
5. 클라이언트가 html파일을 서버에 요청하면 https요청이 아니기 때문에 ca기업이 서버의 정보를 ca기업의 개인키로 암호화한 인증서를 받게된다
*ca기업의 공개키는 브라우저가 이미 알고 있다
6. 브라우저가 해독한 뒤 서버의 공개키를 얻을 수 있다 이제 서버와 통신할 때 이렇게 얻은 공개키를 활용한다

## Load Balancing
둘 이상의 컴퓨터 자원들에게 작업을 할당하는 일

scale up: 성능 향상
scale out: 양을 늘림

이때 여러 서버에 트래픽을 분산 시켜주는 일이 로드 밸런싱

트래픽 분산의 3가지 방법
1. 라운드 로빈
2. least connection: 연결 갯수가 제일 적은 서버 선택
3. source: 사용자 ip를 해싱하여 분배, 특정 사용자가 항상 같은 서버로 연결되는 것을 보장

장애 대비: 로드 밸런서를 이중화

### 질문
1. http와 https를 설명해주세요
http는 인터넷을 이용해 데이터를 주고 받는 규칙
https는 http에 보안이 추가 된 것
2. http의 request  중 get과 post를 설명해주세요
get은 데이터를 조회할 때 쓰이고,
post는 데이터를 쓸 대 사용한다, get보다 보안성이 좋다
3. load balancing을 설명해 주세요
트래픽을 여러 서버로 분산 시키는 기술입니다
