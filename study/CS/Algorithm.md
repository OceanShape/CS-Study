**Algorithm**
[Algorithm](https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html)

# [ 알고리즘 (태훈)]

## 1) 거품 정렬에 대해 설명해 주세요

    인접한 두 원소의 대소를 비교하여 최대값부터 정렬하는 알고리즘
    공간 복잡도는 N이고 시간 복잡도는 N^2입니다

## 2) 선택 정렬에 대해 설명해 주세요

    최소값부터 정렬하는 알고리즘
    공간 복잡도는 N이고 시간 복잡도는 N^2입니다

## 3) 삽입 정렬에 대해 설명해 주세요

    이전의 원소들과 비교하여 삽입할 위치를 찾는 알고리즘
    공간 복잡도는 N이고 시간 복잡도는 N^2입니다
    
    ---
# [ 기수정렬 계수정렬 (수현)]
- 기수 정렬 방법에 대해서 설명해주세요
```
일의자리 숫자부터 N의 자리까지 숫자별로 정렬하는 방식
```
- 계수 정렬 방법에 대해서 설명해주세요
```
각 숫자가 들어온 횟수로 누적합을 구하고, 
누적합에따라 위치를 정해주는 방식
```
- stable sort란 무엇일까요?
```
중복숫자 정렬할때 동일위치로 정렬되는 방식
```
# [ 이분탐색, 해시테이블 (지안)]

### 1 )  이분탐색 (Binary Search) 알고리즘에 대해 설명해주시고 장점과 단점에 대해 말해주세요
     정렬되어 있는 자료를 두 부분으로 나누어서 탐색하는 알고리즘으로,  O(log n)의 시간 복잡도를 가진다.

 **장점** 
- 순차 탐색 (O(N)) 에 비해 훨씬 빠른 성능
- 구현이 간단

**단점** 

- 반드시 정렬되어 있어야 사용할 수 있는 알고리즘
---
### 2 )  해시 테이블이란 무엇인가요?
        딕셔너리 자료형이라고 생각하면 된다. key값을 통해 value값을 평균 O(1)속도로 찾는다. 
        여기서 key값을 특정한 hash값으로 변경해준 뒤 이 hash값으로 value를 찾는데 이러한 hash값을 모아논 자료형이 해시테이블이다.
---        
 ### cf )  해시 테이블 시간 복잡도      
        각각의 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간복잡도로 데이터를 조회할 수 있다.

        하지만 데이터의 충돌이 발생한 경우 Chaining에 연결된 리스트들까지 검색을 해야 하므로 O(N)까지 시간복잡도가 증가할 수 있다.

        충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만 공간을 많이 사용한다는 치명적인 단점이 있다.

        만약 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확정을 하지 않도록 테이블을 설계해주어야 한다.

        (통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)

        또한 해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다.

        출처: https://mangkyu.tistory.com/102)
--- 
        


# [ 최소 공통조상 LCA, DP (예빈) ]

### 1 )  최소 공통조상 알고리즘에 대해서 설명해주세요. 그리고 구현 방법에 대해서 설명해주세요. 어떤 자료 구조를 사용하나요?
     선택된 두 노드의 가장 먼저 찾은 공통 조상을 의미한다. 예를들어, 순서대로 만들어진 이진 트리에서, 4와 5의 LCA는? → 2 가된다. 
     트리에서 각각의 노드에 해당하는 부모 노드의 값을 parent라는 배열에 저장해서 구현한다. 
     반복문을 돌며, 만약 노드의 parent가 같지 않다면, 두 정점을 자신의 parent 정점 값으로 변경하여 같아질때까지 찾는 방식으로 구현된다. 

### 2 )  DP에 대해서 설명하고, DP를 사용할수 있는 조건 두가지를 설명하세요. 
        한 가지 문제에 대해서, 단 한 번만 풀도록 만들어주는 알고리즘이다.
        조건 두가지: 
        1)작은 문제에서 반복이 일어남
        2)같은 문제는 항상 정답이 같음
---        
 ### 3 )  DP를 구현할수 있는 방법 두가지와 각각의 장담점을 설명하세요.  
        Bottom-up : 작은 문제부터 차근차근 구하는 방법
        Top-down : 큰 문제를 풀다가 풀리지 않은 작은 문제가 있다면 그때 해결하는 방법 (재귀 방식)

 **장단점** 
- Bottom-up은 해결이 용이하지만, 가독성이 떨어짐
- Top-down은 가독성이 좋지만, 코드 작성이 힘듬
--- 

 ### Bonus )  DP를 사용해본 예시를 나눠주세요. 
        대표적으로 피보나치의 수열이 있다. 
        가장 기억에 남는 문제: https://www.acmicpc.net/problem/17070
        3차원으로 풀어야 했던 DP 문제....
--- 
        